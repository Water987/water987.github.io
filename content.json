{"meta":{"title":"生命不息，编程不止","subtitle":"water","description":"code","author":"water","url":"https://water987.github.io","root":"/"},"pages":[],"posts":[{"title":"学习过程中的RabbitMQ问题解答","slug":"RabbitMQQuestioninLearning","date":"2022-10-08T04:00:00.000Z","updated":"2022-10-08T07:50:18.708Z","comments":true,"path":"2022/10/08/RabbitMQQuestioninLearning/","link":"","permalink":"https://water987.github.io/2022/10/08/RabbitMQQuestioninLearning/","excerpt":"","text":"Q:RabbitMQ作用？异步处理，应用解耦，流量控制 Q：消息队列的主要的两种形式的目的地1.队列（queue）：点对点消息通信（point-to-point） 2.主题（topic）：发布（publish）/订阅（subscribe）消息通信 Q：JMS(Java Message Service) 与 AMQP区别 Q:Exchange分发策略有哪些，是怎么做的direct：消息中的路由键（routing key）如果和Binding 中的 binding key 一致， 交换器 就将消息发到对应的队列中。完全匹配，单播模式 headers：与direct基本一致，headers匹配AMQP的header，而不是路由键 fanout：分配消息到所有绑定的队列上，类似广播 topic：通过模式匹配分配消息的 路由键属性，将路由键和某个模式进行匹配，可使用通配符匹配，#匹配1到多个，*匹配一个 Q：消息队列的可靠抵达是如何实现的 生产者 到 broker 在创建链接工厂时，开启confirmCallback，消息只要被 broker 接收到就会执行 confirmCallback，集群模式下需要所有broker接收到才执行 confirmCallback 交换机 到 队列 开启returnCallback,，如果未能投递到目标 queue 里将调用 returnCallback 队列 到 消费者 消费者获取到消息，成功处理，可以回复Ack给Broker Q：消息可靠性会遇到的问题有哪些，如何解决消息丢失：网络原因消息为抵达broker， ​ 容错方法，try catch 记录数据库，定期扫描重发 ​ 日志记录，消息状态应该有记录 ​ 定期重发 消息重复： 消费成功，ack时宕机 ​ 接口幂等性 ​ 防重表 ​ 查看消息的redelivered字段 消息积压：消费者宕机，消费能力不足，发送者流量太大 ​ 上线更多消费者 ​ 消息批量取出，存储到是数据库，离线处理 Q：RabbitMQ如何实现定时任务消息设置TTL(过期时间)搭配死信Exchange Q：RabbitMQ连接方式长连接 Q：常见消息队列中间件有哪些 ActiveMQ、RabbitMQ、RocketMQ、Kafka","categories":[{"name":"中间件","slug":"中间件","permalink":"https://water987.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://water987.github.io/tags/RabbitMQ/"}]},{"title":"学习过程中的Java问题解答","slug":"JavaQuestionInLearning","date":"2022-09-02T08:10:38.000Z","updated":"2022-09-27T08:35:17.889Z","comments":true,"path":"2022/09/02/JavaQuestionInLearning/","link":"","permalink":"https://water987.github.io/2022/09/02/JavaQuestionInLearning/","excerpt":"","text":"Q: 如何根据一个list 生成一个新的listList newList = new ArrayList(oldList); Q: 运行时异常，非运行时异常A:运行时异常都是RuntimeException类及其子类异常非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。 Q:为什么123Integer i = 50000;Integer k = 50000;System.out.println((i/1000==k/1000)+&quot;,&quot;+(i==k)); 输出结果为 true , falseA：Integer 与 int 运算 解包 =》结果为int，Integer==Integer 判断hashcode() Q：对象是如何判断相等的，Integer 是如何判断相等的，字符串是如何判断相等的。A：1.对象==对象 会判断两个对象的 hashcode() 相等为true 否则 false2.Integer == int 会自动解包，两个int数 对比3.字符串 拥有常量，对象两种形式，没有自动解包，因此 对象==对象 找hashcode()，对象==常量 false, 常量==常量 true , 常量拼接对象 变对象 Q:看到算法题时，考虑不全，写到一半发现数据结构不合适，然后重写Q: 同步/异步 阻塞/非阻塞同步，异步 是对 被调用者阻塞，非阻塞是对 调用者来说同步阻塞，调用者调用后阻塞，被调用者完成后返回。 例： 大爷烧水，等待水开。同步非阻塞，调用者调用后，轮询结果，被调用者完成后返回。例： 大爷一会看电视，一会过来 看看水有没有开。异步阻塞，少见 例：大爷烧水，等待会响的水壶水开异步非阻塞，调用者调用后，做别的事情，被调用者立即返回结果，等做完后回调。 例：大爷看电视，水烧开，壶会响，然后去处理开水。 Q:String 为什么不可修改，字符串常量与字符串变量的关系，存储位置Q:String a = “abc” 发生了什么 Q:Java中类中 {}代码块是什么结构 Q:子类实例赋值给父类引用，方法调用是如何表现的 Q:如何将JVM知识体系映射到实际的代码运行，类，对象，变量，字符串的存储位置 Q:重载方法，返回值能否区分两个方法。不能，会报编译失败。额外的 重写方法返回值必须是父类或其子类 Q:运行时异常，非运行时异常，可抛出异常有哪些 Q:Object类有哪些方法 Q:public，protected，private，默认访问权限，区别及作用 Java的访问控制是停留在编译层的，也就是它不会在.class文件中留下任何的痕迹，只在编译的时候进行访问控制的检查。其实，通过反射的手段，是可以访问任何包下任何类中的成员，例如，访问类的私有成员也是可能的。 Q:运行时常量池中都有什么类的版本，字段，方法，接口等描述信息。常量池，用于存放编译期生成的各种字面量和符号引用, Q:JVM内存有什么线程私有： 程序计数器，指向虚拟机字节码指令的位置 虚拟机栈，调用方法创建栈帧，存储本地变量表，操作数栈，对运行时常量池的引用，动态连接，方法出口 本地方法栈 线程共享： 方法区，永久代，运行时常量池，存储JVM加载的类信息，常量，静态变量，即时比那一起编译后的代码 堆，存放创建的对象，数组，垃圾回收最重要内存区域 Q:编译时类型，运行时类型是什么，有什么区别编译时类型由声明对象时 使用的类型决定 运行时类型由实际赋值给对象的类型决定 12Person p = new Student();编译时类型：Person。 运行时类型：Student Q:java内部类静态内部类：public class内 的静态类 成员内部类：public class内 的类 局部内部类：定义在方法中的类 匿名内部类：要继承一个父类或者实现一个接口，直接使用new来生成一个对象的引用 Q:父类 子类 都有的方法调用遵循什么原则Q:编译时静态绑定,运行时动态绑定是什么Q:java静态变量、代码块、和静态方法的执行顺序是什么？ 代码块执行顺序静态代码块——&gt; 构造代码块 ——&gt; 构造函数——&gt; 普通代码块 继承中代码块执行顺序：父类静态块——&gt;子类静态块——&gt;父类代码块——&gt;父类构造器——&gt;子类代码块——&gt;子类构造器 Q:Java语言是如何实现多态的？Java实现多态有 3 个必要条件：继承、重写和向上转型。 Q:编译时多态，运行时多态编译时多态，编译时多态在编译时就已经确定，运行的时候调用的是确定的方法。主要是方法重载，调用会根据 声明类调用 而不是实际引用类 运行时多态，运行时按照实际类型调用 Q:Java8 有什么新特性lambda表达式 函数式接口 方法引用 默认方法 StreamAPI 新的日期API Java中几种常量池的区分全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中 class文件常量池，class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的**各种字面量(Literal)和符号引用(Symbolic References)**。 运行时常量池，jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。 Q:枚举类是什么，怎么用Q:synchronized 与 volatile 关键字 是什么，什么作用 volatile 保证变量对所有的线程的可见性，当volatile变量被修改该时，新值对所有线程会立即更新 volatile保证了 可见性，有序性，不保证原子性 Q:设计模式七大原则 标记 设计模式原则名称 简单定义 OCP 开闭原则 对扩展开放，对修改关闭 SRP 单一职责原则 一个类只负责一个功能领域中的相应职责 LSP 里氏代换原则 所有引用基类的地方必须能透明地使用其子类的对象 DIP 依赖倒转原则 依赖于抽象，不能依赖于具体实现 ISP 接口隔离原则 类之间的依赖关系应该建立在最小的接口上 CARP 合成/聚合复用原则 尽量使用合成/聚合，而不是通过继承达到复用的目的 LOD 迪米特法则 一个软件实体应当尽可能少的与其他实体发生相互作用","categories":[{"name":"java","slug":"java","permalink":"https://water987.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://water987.github.io/tags/java/"}]},{"title":"学习过程中的SQL问题解答","slug":"SQLQuestionInLearning","date":"2022-09-02T03:14:53.000Z","updated":"2022-09-27T04:52:28.297Z","comments":true,"path":"2022/09/02/SQLQuestionInLearning/","link":"","permalink":"https://water987.github.io/2022/09/02/SQLQuestionInLearning/","excerpt":"","text":"Q:MySQL查询语句的执行顺序正确的执行顺序应该是●先找到要查询表格或连接要查询的表格，因此FROM才是第一步；●接下来是进行条件筛选，所以是WHERE紧随其后；●然后如果遇到表格有分组的需要，则需要先GROUP BY；●分组时如果也存在筛选条件，这里就要用HAVING进行分组筛选；●这些执行过后才是查询操作SELECT；●SELECT的时候如果遇到重复数据，就需要去重，即使用DISTINCT;●接下来如果要对查询后的数据进行排序，会用到ORDER BY；●最后如果要指定返回的查询数据范围、条数则要用LIMIT/OFFSET函数 Q: 什么是存储过程A:存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。 Q: sql语句 行转列原本数据是一个人多行数据，每行一个成绩，现在要行转列，因此需要按学号分组，组内将数据拆成列 Q: mysql联结操作 Q: mysql 中 having，where 执行顺序A: where 在数据分组前进行过滤，having在数据分组后进行过滤。 Q:if 语句如何使用A:if(列=条件，true返回，false返回) Mysql常用命令12// 连接数据库mysql -u username -p -h mysql地址 -P 端口 mysql函数123456//拼接字符串Concat(str1,str2,...)// 去掉 字符串 最左 最右空格LTrim(str) RTrim(str)Trim(str) 日期，时间处理函数 mysql 8.0 函数链接 Q:mysql面对亿级别的数据该如何处理 Q:如何维护一个热点数据Q:三种日志文件 undo log，redo log，binlogbinlog MySQL的 binlog 是记录所有数据库表结构变更（例如 CREATE、ALTER TABLE）以及表数据修改（INSERT、UPDATE、DELETE）的二进制日志。MySQL binlog 以事件形式记录，还包含语句所执行的消耗的时间，MySQL 的二进制日志是事务安全型的。binlog 的主要目的是复制和恢复。 undo log undo log 用来回滚行记录到某个版本。事务未提交之前，Undo 保存了未提交之前的版本数据，Undo 中的数据可作为数据旧版本快照供其他并发事务进行快照读。是为了实现事务的原子性而出现的产物,在 MySQL innodb 存储引擎中用来实现多版本并发控制。 redo log redo log 不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入 redo 中。具体的落盘策略可以进行配置 。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 MySQL 服务的时候，根据 redo log 进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。RedoLog 是为了实现事务的持久性而出现的产物。 Q:Schema与数据类型优化Q:海量数据业务有哪些优化手段？ 缓存加速 ==&gt; 如何使用缓存？​ redis，本地缓存，分布式缓存。​ 数据预热 主从读写分离 ==&gt; 如何实现数据备份？​ 修改业务代码，改完主库，同步更新备库​ 监控数据库binlog日志（可以引入canal组件）​ 备份时查询策略 1. 不让访问。2.实时性不高，走备库。3.实时性高，走主库。 垂直拆分（按业务拆分） ==&gt; 分布式事务解决方案？​ 数据表垂直拆分就是纵向地把一张表中的列拆分到多个表，表由“宽”变“窄”，简单来讲，就是将大表拆成多张小表，一般会遵循以下几个原则：​ 冷热分离，把常用的列放在一个表，不常用的放在一个表。​ 字段更新、查询频次拆分​ 大字段列独立存放​ 关系紧密的列放在一起 分库分表 ==&gt; 垂直分表原则，水平分表原则，如何分？​ SQl组合。因为是逻辑表名，需要按分表键计算对应的物理表编号，根据逻辑重新组装动态的SQL​ 数据库路由。如果采用分库，需要根据逻辑的分表编号计算数据库的编号​ 结果合并。如果查询没有传入指定的分表键，会全库执行，此时需要将结果合并再输出。 冷热数据分离 ==&gt;冷热数据区分的标准是什么？如何触发冷热数据的分离? ES助力复杂查询 ==&gt; mysql与ES的概念关系映射？ NoSql ==&gt; 五类NoSql数据库 NewSql（新一代分布式数据库）==&gt; 常见的 New SQL 数据库 海量数据业务有哪些优化手段？ Q:如何使用缓存Q:如何实现数据备份Q:垂直分表原则，水平分表原则，如何分？水平分表 分库分表技术点： 水平分表两种模式 Proxy模式。SQL 组合、数据库路由、执行结果合并等功能全部存放在一个代理服务中，业务方可以当做。 优点：支持多种语言。升级方便。对业务代码无侵入。 缺点：额外引入一个中间件，容易形成流量瓶颈，安全风险较高，有运维成本 Client 模式。常见是 sharding-jdbc，业务端系统只需要引入一个jar包即可，按照规范配置路由规则。jar 中处理 SQL 组合、数据库路由、执行结果合并等相关功能。 优点：简单、轻便。不存在流量瓶颈，减少运维成本 缺点：单语言，升级不方便。 数据量大，就分表；并发高，就分库 Q:冷热数据区分的标准是什么？如何触发冷热数据的分离?​ 1.时间 2. 状态 3.组合 ​ 触发方式，1.修改业务代码 2.监听binlog 3.跑定时任务 Q:mysql与ES的概念关系映射？ Q:五类NoSql数据库 KV 数据库，通常基于哈希表实现，性能非常好。其中 Value 的类型通常由应用层代码决定。常用的如 Redis 文档型数据库，如：MongoDB、CouchDB ，这种数据库的特点是 Schema Free（模式自由），数据表中的字段可以任意扩展。 列式数据库，比如 Hbase、Cassandra。列式数据库基于 Key 来映射行，再通过列名进行二级映射，同时它基于列来安排存储的拓扑结构，这样当仅读写大量行中某个列时，操作的数据节点、磁盘非常集中，磁盘 IO、网络 IO 都会少很多。 图数据库，在社交关系、知识图谱等场景中，携带各种属性的边可以表示节点间的关系 时序数据库，如：InfluxDB，一般用来做 Metrics 打点。时序数据库的优势，在于处理指标数据的聚合，并且读写效率非常高。 Q:常见的 New SQL 数据库Google 的 Cloud Spanner、阿里巴巴的 OceanBase 以及开源的CockroachDB。 Q:MySQL的事务隔离级别良好事务标准特征：ACID，原子性，一致性，隔离性，持久性 读未提交（READ UNCOMMITTED） 问题：脏读，读到其他事务未提交数据 读已提交（READ COMMITTED） 问题：不可重复读，读取一次数据后，其他事务修改，再次读不一致。 可重复读（REPEATABLE READ） 问题：幻读，事务1读取某个范围内的记录时，事务2又在该范围插入新纪录，事务1再次读取该范围记录时，会产生幻行。 InnoDB存储引擎通过多版本并发控制（MVCC）解决幻读。MySQL默认事务隔离级别。 串行化（SERIALIZABLE） 强制事务串行执行 Q:多版本并发控制（MVCC）可以认为MVCC是行级锁的一个变种，但是在很多情况下避免了加锁操作，通过保存数据在某个时间点的快照来实现（InnoDB 为表每一行加上创建版本号，删除版本号） 不同存储引擎的MVCC实现方式不同，典型的有乐观并发控制和悲观并发控制 Q:B树索引适用于哪些查询 全值匹配，和索引中的所有列进行匹配 匹配最左前缀，只使用索引的第一列 匹配列前缀，只匹配某一列的开头部分 匹配范围值，查找某两个值之间的数据 精确匹配某一列并范围匹配另外一列，精确匹配第一列，范围匹配第二列 只访问索引的查询 因为索引树中的节点是有序的，除了按值查找之外，还可以用于查询中的order by 操作（按顺序查找） 限制 不是按照索引的最左列开始查找，无法使用索引 不能跳过索引中的列 查询中有某个列的范围查询，其右边所有列复发使用索引优化差查找 Q:索引优点 减少服务器需要扫描的数据量 帮助服务器避免排序和临时表 将随机I/O变为顺序I/O Q:高性能的索引策略 独立的列 123查询中的列不是独立的，则MySQL不会使用索引“独立的列” 是指索引列不能是 表达式的一部分 ，也不能是 函数的参数养成简化where条件习惯，始终将索引列当都放在比较符合号的一侧。 前缀索引和索引选择性 123前缀索引：索引很长的字符列，可以索引开始的部分字符，节约索引空间索引的选择性：不重复的索引值 和 数据表总记录数的比值无法使用前缀索引做order by 和 group by,也无法使用前缀索引做覆盖扫描 组合索引 123多个列建立单独索引大部分情况不能提高查询性能，mysql5.0后引入了“索引合并策略”，一定程度上使用多个单列索引定位指定行多个索引做相交操作时（通常多个AND）意味着需要一个包含所有相关列的多列索引多个索引做联合操作时，会使用Union 合并两个条件结果 选择合适的索引列顺序 1一般将选择性高的列放在前边 聚簇索引 123456一种数据存储方式，InnoDB的聚簇索引实际上在同一结构中保存了B-Tree索引和数据行术语 聚簇：表示数据行和相邻的键值紧凑的存储在一起。无法同时将数据行放在两个地方，所以一个表只能有一个聚簇索引优点：将相关数据保存到一起。数据访问更快。覆盖索引扫描的查询可以直接使用页节点中的主键值。 覆盖索引 1覆盖索引是select的 “数据列” 只用从索引中就能够取得，不必读取 “数据行” 使用索引扫描来做排序 1explain type 列为 index 说明使用了索引扫描来排序 压缩（前缀压缩）索引 避免冗余和重复索引 1唯一限制 主键限制 都是通过索引实现的，一列有多个以上限制 会创建三个重复索引 删除未使用的索引 索引和锁 1索引可以让查询 锁定更少的行 Q:什么是三星索引★☆☆ 定义：如果与一个查询相关的索引行是相邻的，或者至少相距足够靠近的话，那这个索引就可以标记上一颗星。 收益：它最小化了必须扫描的索引片的宽度。 实现：把 WHERE 后的等值条件列作为索引最开头的列，如此，必须扫描的索引片宽度就会缩至最短。 ★★☆ 定义：如果索引行的顺序与查询语句的需求一致，则索引可以标记上第二颗星。 收益：它排除了排序操作。 实现：将 ORDER BY 列加入到索引中，保持列的顺序 ★★★ 定义：如果索引行中包含查询语句中的所有列，那么这个索引就可以标记上第三颗星。 收益：这避免了访问表的操作（避免了回表操作），只访问索引就可以满足了。 实现：将查询语句中剩余的列都加入到索引中。 Q:什么时候会用到索引，like，order by 什么时候可以用索引，什么时候不能用索引 Q: InnoDB 单表支持数据量InnoDB一棵B+树可以存放约2千万行数据？ 计算机中磁盘存储数据最小单元是扇区，一个扇区的大小是512字节 文件系统（例如XFS/EXT4）他的最小单元是块，一个块的大小是4k InnoDB存储引擎最小储存单元——页（Page），一个页的大小是16K Q:为什么MySQL的索引要使用B+树而不是其它树形结构?比如B树？B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低； B+树非叶节点不存储数据，查询效果更稳定 B+树叶子节点相连，区间查找更方便 Q:如何使用explainQ:慢查询该如何优化最基本原因：访问的数据太多 确认是否检索大量超过需要的数据（访问太多行，或者太多列） 确认MySQL服务器层是否分在分析大量超过需要的数据行。 是否向数据库请求了不需要的数据 查询了不需要的记录， 可以使用limit优化 多表关联时返回全部列， 只取需要的列（select 列1, 列2 ） 总是取出所有列，会让优化器无法完成索引覆盖这类优化，（用到缓存时，取所有列， ） 重复查询相同的的数据， 重复查询时可以将数据缓存起来 Q:数据库锁按锁粒度 ​ 行级锁：共享锁 和 排他锁 ​ 表级锁：表共享读锁（共享锁）与表独占写锁（排他锁） ​ 页级锁：一次锁定相邻的一组记录。BDB支持页级锁 按锁类别 ​ 共享锁 ​ 排他锁 按锁的实现方式 ​ 乐观锁 ​ 悲观锁 记录锁，间隙锁，临键锁 记录锁是 封锁记录，记录锁也叫行锁 间隙锁是封锁索引记录中的间隔，或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围。 临键锁的主要目的，也是为了避免幻读(Phantom Read)。 Q:事务实现原理事务是基于重做日志文件(redo log)和回滚日志(undo log)实现的。 每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。 每当有修改事务时，还会产生 undo log，如果需要回滚，则根据 undo log 的反向语句进行逻辑操作，比如 insert 一条记录就 delete 一条记录。undo log 主要实现数据库的一致性。 Q:主键索引和普通索引的区别 Q:Index Condition Pushdown（索引下推）","categories":[{"name":"SQL","slug":"SQL","permalink":"https://water987.github.io/categories/SQL/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://water987.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}],"categories":[{"name":"中间件","slug":"中间件","permalink":"https://water987.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"java","slug":"java","permalink":"https://water987.github.io/categories/java/"},{"name":"SQL","slug":"SQL","permalink":"https://water987.github.io/categories/SQL/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://water987.github.io/tags/RabbitMQ/"},{"name":"java","slug":"java","permalink":"https://water987.github.io/tags/java/"},{"name":"数据库","slug":"数据库","permalink":"https://water987.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}